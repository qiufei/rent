---
title: "under_median"
author: "Qiufei"
date: "1/20/2017"
output: 
  html_document: 
    number_sections: yes
    theme: cerulean
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

我们的目的，先计算出妹纸股票最新收盘价与其前一自然年度中收盘价中位数之比under_ratio，然后按照under_ratio的值对股票进行升序排序，然后从中选出排在最前面的10只股票。

这10只股票我们认为价格较低。

## 载入宏包、数据集并设定一些参数

```{r}

# 载入宏包dplyr，此包的作用是对数据集(dataframe)进行操作
library(dplyr)

# 载入宏包lubridate，此包的作用是对日期数据进行操作
library(lubridate)

# 载入股市交易数据
load('stock.rda')

# 我们要过去一年的数据来计算股价的中位数
# 所以先设置好历史数据的时间区间，从2015年12月31日到2016年12月31日
end_date = ymd('2016-12-31')
begin_date = end_date - years(1)


```


## 从股市数据集中提取出我们需要的历史区间内的数据

```{r}

# summary()函数可以看数据集的结果
# 从函数返回的结果,我们可以看到数据集stock的原始区间是从2012年11月26日开始，到2017年1月18日结束

summary(stock)

# 使用dplyr中的filter函数，提取我们需要的时间段内的数据
past_year = filter(stock,date >= begin_date & date<= end_date)

```

为什么我们设定的结束日期是2016年12月31日，而summary函数返回的结果显示日期只到2016年12月30日呢？因为16年12月31日那天是休息日，股市不开始，所以那天没有数据。

## 计算每只股票的最新价格与历史中位数的比值

### 对股票数据进行分组

```{r}

# 我们要对每只股票的收盘价（close）计算under_ratio，
# 所以要对数据先按股票代码进行分组，分组函数是dplyr包中的group_by()函数
# group_by函数的第一个参数是需要进行分组的数据集，本次分组对象为past_year
# group_by函数的第二个参数是分组的标记，就是按照什么标准分组，本次是按照股票代码code分组
past_group = group_by(past_year,code)




```

### 分别计算每只股票的最新价格与其历史中位数的比值

```{r}

past_median = summarise(past_group,
                        history_date = first(date),
                        median_close = median(close)
                        )

# history_date 记录的是股票交易的最后一天的时间
# 股票数据是按照时间降序排列的，也就说日期越晚的数据排在越前面
# first函数是获取排在第一位的数据

```

### 获得每只股票最新的价格
同样，对每只股票进行操作的时侯，我们需要先对数据集按照股票代码进行分组

```{r}

stock_group = group_by(stock,code)

current_close = summarise(stock_group,
                          newest_date = first(date),
                          newest_close = first(close)
                          )

```

### 将保存历史中位数的数据集past_median和保存最新价格的数据集current_close合并

```{r}
# merge 函数有三个参数
# 第一和第二个是要合并的数据集的名字
# 第三个是对数据集进行合并的标示变量，可以理解为将什么变量作为不同数据的身份证
past_current = merge(past_median,current_close,by = "code")

```
* 为什么要合并这两个数据集？
当我们需要对两个相关的变量进行操作的时侯，最好把她们放到一个对象里去。

>  你们会遇见不同的人，走过不同的路，但是在R数据分析里，最好把数据放到同一个dataframe中。


### 计算under_ratio指标

我们定义under_ratio = newest_close/median_close

```{r}

# mutate函数来自dplyr宏包
# past_current数据集现在多了under_ratio这一列
# 我们把这个新的数据集命名为under_close
under_close = mutate(past_current,
                     under_ratio = newest_close/median_close
                     )

```

### 在under_close数据集中对股票按照 under_ratio升序排列

```{r}
# arrange函数来自dplyr宏包
under_close_sort = arrange(under_close,under_ratio)

# 取出under_close_sort中排名前10的股票
under_close_top10 = head(under_close_sort,10)

```

## 估算买入和卖出价格

* 分别计算这10只股票有数据以来的收盘价格的分位数


* 如果股价低于25% 分位点价格U，那么就买入

* 如果股价高于50% 分位点价格，那么就卖出

### 计算这10只股票的前一年的标准差

```{r}

# 提取这10只股票的
under_top10 = filter(stock_group, code %in% under_close_top10$code)

# 计算这十只股票的75%分位点价格
under_top10_q50 = summarize(under_top10_group,quantile_50 = quantile(close)["50%"])

# 计算这十只股票的25%分位点价格
under_top10_q25 = summarize(under_top10_group,quantile_25 = quantile(close)["25%"])


```

### 将这10只股票的历史价格的交易所用信息汇总


```{r}

# 将两个分位点价格信息合并到一个数据集中
under_quantile = merge(under_top10_q25,under_top10_q50, by = "code")

# 将分位点信息与最新价格、以及under_ratio值合并
under_all = merge(under_close_top10[,c("code","under_ratio","newest_close")],under_quantile, by = "code")

```







