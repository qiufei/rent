---
title: "一个天真的低价买入策略"
author: "邱飞"
date: "万里学院"
output:
  revealjs::revealjs_presentation:
    theme: sky
    reveal_options:
      slideNumber: true
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
library(dplyr)
```

## 我们的目的 ##

* 先计算出每只股票最新收盘价与其前一自然年度中收盘价中位数之比under_ratio，

* 然后按照under_ratio的值对股票进行升序排序，

* 然后从中选出排在最前面的10只股票。

这10只股票我们认为价格较低。

## 载入宏包、数据集并设定一些参数 ##

```{r}

# 载入宏包dplyr，此包的作用是对数据集(dataframe)进行操作
library(dplyr)

# 载入宏包lubridate，此包的作用是对日期数据进行操作
library(lubridate)

# 载入股市交易数据
load('stock_clean.rda')

# 我们要过去一年的数据来计算股价的中位数
# 所以先设置好历史数据的时间区间，从2015年12月31日到2016年12月31日
end_date = ymd('2016-12-31')
begin_date = end_date - years(1)


```


## 从股市数据集中提取出我们需要的历史区间内的数据 ##

```{r}

# summary()函数可以看数据集的结果
# 从函数返回的结果,我们可以看到数据集stock的原始区间是从2012年11月26日开始，到2017年1月18日结束

summary(stock_clean)

# 使用dplyr中的filter函数，提取我们需要的时间段内的数据
past_year = filter(stock_clean,date >= begin_date & date<= end_date)

```

为什么我们设定的结束日期是2016年12月31日，而summary函数返回的结果显示日期只到2016年12月30日呢？因为16年12月31日那天是休息日，股市不开始，所以那天没有数据。

## 股票的最新价格与历史中位数的比值 ##

* 这里又需要我们之前操作课上讲到的分组 

* 分组和筛选，需要熟练掌握

## 对股票数据进行分组 ##

```{r}

# 我们要对每只股票的收盘价（close）计算under_ratio，
# 所以要对数据先按股票代码进行分组，分组函数是dplyr包中的group_by()函数
# group_by函数的第一个参数是需要进行分组的数据集，本次分组对象为past_year
# group_by函数的第二个参数是分组的标记，就是按照什么标准分组，本次是按照股票代码code分组
past_group = group_by(past_year,code)

```

## 分别计算每只股票的最新价格与其历史中位数的比值 ##

```{r}

past_median = summarise(past_group,
                        history_date = first(date),
                        median_close = median(close)
                        )

# history_date 记录的是股票交易的最后一天的时间
# 股票数据是按照时间降序排列的，也就说日期越晚的数据排在越前面
# first函数是获取排在第一位的数据

```

## 每只股票最新的价格 ##

同样，对每只股票进行操作的时侯，我们需要先对数据集按照股票代码进行分组

```{r}

stock_group = group_by(stock_clean,code)

current_close = summarise(stock_group,
                          newest_date = first(date),
                          newest_close = first(close)
                          )

```

## merge历史中位数和最新价格 ##

* 保存历史中位数的数据集past_median
* 保存最新价格的数据集current_close


```{r}
# merge 函数有三个参数
# 第一和第二个是要合并的数据集的名字
# 第三个是对数据集进行合并的标示变量，可以理解为将什么变量作为不同数据的身份证
past_current = merge(past_median,current_close,
                     by = "code") 

```

## 为什么要合并这两个数据集 ##

* 当需要对两个相关的变量进行操作的时侯，最好把她们放到一个对象里去。

> 你们会遇见不同的人，走过不同的路，但是在R数据分析里，最好把相关数据放到同一dataframe中。


## 计算低估率指标 ##

* past_current数据集现在多了低估率这一列

* 新的数据集命名为under_close

```{r under value ratio}
under_close = mutate(past_current,
                     under_ratio = newest_close/median_close)
```


## 在新的数据集排序 ##

* 新的操作对象数据集为under_close

* 对其中的股票按照低估率升序排列

```{r under close sort}

under_close_sort = arrange(under_close,under_ratio)

```


## 确定买入和卖出价格 ##

* 分别计算这10只股票有数据以来的收盘价格的分位数

* 如果股价低于四分之一分位点价格，那么就买入

* 如果股价高于二分之一分位点价格，那么就卖出


## 获取选定的十只股票的前一年的标准差 ##

```{r top10}


# 取出under_close_sort中排名前10的股票
under_close_top10 = head(under_close_sort,10) 

# 提取这10只股票的数据
under_top10 = filter(stock_group, 
                     code %in% under_close_top10$code) 

# 计算这十只股票的75%分位点价格
under_top10_q50 = summarize(under_top10,
                            quantile_50 = quantile(close)["50%"]) 

# 计算这十只股票的25%分位点价格
under_top10_q25 = summarize(under_top10,
                            quantile_25 = quantile(close)["25%"]) 


```


## 将这十只股票的历史价格的交易所用信息汇总 ##


```{r summary}
# 将两个分位点价格信息合并到一个数据集中
under_quantile = merge(under_top10_q25,
                       under_top10_q50, 
                       by = "code") 

# 将分位点信息与最新价格、以及under_ratio值合并
under_all = merge(under_close_top10[,c("code","under_ratio","newest_close")],
                  under_quantile, 
                  by = "code") 

```

## 显示操作报告 ##

```{r report,echo= FALSE}


kable(under_all)

```






